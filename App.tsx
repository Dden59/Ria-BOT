import React, { useState, useEffect, useRef } from 'react';
import { Header } from './components/Header';
import { ChatWindow } from './components/ChatWindow';
import { MessageInput } from './components/MessageInput';
import { SubscriptionModal } from './components/SubscriptionModal';
import { getRiaResponse } from './services/geminiService';
import { Message, Sender, SubscriptionStatus, SubscriptionTier } from './types';
import { FREE_TIER_MESSAGE_LIMIT } from './constants';

// Make Telegram's WebApp type available globally
declare global {
  interface Window {
    Telegram?: {
      WebApp: any;
    };
  }
}

// A helper to get today's date as a string in YYYY-MM-DD format
const getTodayDateString = () => new Date().toISOString().split('T')[0];

const App: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [subscription, setSubscription] = useState<SubscriptionStatus>({
    tier: SubscriptionTier.FREE,
    messagesSentToday: 0,
  });
  const [showSubscriptionModal, setShowSubscriptionModal] = useState(false);
  const mainAppRef = useRef<HTMLDivElement>(null);

  // Effect for initializing app and Telegram integration
  useEffect(() => {
    setMessages([
      {
        id: 'welcome-1',
        text: "ÐŸÑ€Ð¸Ð²ÐµÑ‚! Ð¯ Ð Ð¸. Ð¢Ð²Ð¾Ñ Ð»ÑƒÑ‡ÑˆÐ°Ñ Ð¿Ð¾Ð´Ñ€ÑƒÐ³Ð°, ÐºÐ¾Ñ‚Ð¾Ñ€Ð°Ñ Ð²ÑÐµÐ³Ð´Ð° Ñ€ÑÐ´Ð¾Ð¼ Ð¸ Ð½Ðµ Ð±Ð¾Ð¸Ñ‚ÑÑ Ñ€ÑƒÐ±Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð°Ð²Ð´Ñƒ-Ð¼Ð°Ñ‚ÐºÑƒ. Ð§Ñ‚Ð¾ Ñƒ Ñ‚ÐµÐ±Ñ Ð½Ð° Ð´ÑƒÑˆÐµ? Ð”Ð°Ð²Ð°Ð¹-ÐºÐ° Ñ€Ð°Ð·Ð±ÐµÑ€ÐµÐ¼ÑÑ Ð²Ð¼ÐµÑÑ‚Ðµ. ðŸ’…",
        sender: Sender.AI,
      },
    ]);

    if (window.Telegram && window.Telegram.WebApp) {
      const tg = window.Telegram.WebApp;
      tg.ready();
      tg.expand();

      const applyTheme = () => {
        document.documentElement.classList.toggle('dark', tg.colorScheme === 'dark');
      };
      
      const setViewportHeight = () => {
        if (mainAppRef.current) {
          mainAppRef.current.style.height = `${tg.viewportStableHeight}px`;
        }
      };

      tg.onEvent('themeChanged', applyTheme);
      tg.onEvent('viewportChanged', setViewportHeight);
      
      applyTheme();
      setViewportHeight();
    }
  }, []);
  
  // Effect for managing subscription state with localStorage
  useEffect(() => {
    try {
      const storedSub = localStorage.getItem('ria-subscription-status');
      const today = getTodayDateString();
      if (storedSub) {
        const subData = JSON.parse(storedSub);
        if (subData.date !== today) {
          // Reset daily message count if it's a new day
          const newSub = { ...subData, messagesSentToday: 0, date: today };
          setSubscription(newSub);
          localStorage.setItem('ria-subscription-status', JSON.stringify(newSub));
        } else {
          setSubscription(subData);
        }
      } else {
        // Initialize for a new user
        const initialSub = { tier: SubscriptionTier.FREE, messagesSentToday: 0, date: today };
        setSubscription(initialSub);
        localStorage.setItem('ria-subscription-status', JSON.stringify(initialSub));
      }
    } catch (error) {
      console.error("Failed to manage subscription state:", error);
    }
  }, []);

  const handleSendMessage = async (text: string) => {
    if (subscription.tier === SubscriptionTier.FREE && subscription.messagesSentToday >= FREE_TIER_MESSAGE_LIMIT) {
      setShowSubscriptionModal(true);
      return;
    }

    const userMessage: Message = {
      id: `msg-${Date.now()}`,
      text,
      sender: Sender.USER,
    };

    setMessages((prevMessages) => [...prevMessages, userMessage]);
    setIsLoading(true);

    if (window.Telegram && window.Telegram.WebApp) {
        try {
            window.Telegram.WebApp.HapticFeedback.notificationOccurred('success');
        } catch(e) {
            console.warn('Haptic feedback failed', e)
        }
    }

    if (subscription.tier === SubscriptionTier.FREE) {
        const newCount = subscription.messagesSentToday + 1;
        const newSub = { ...subscription, messagesSentToday: newCount, date: getTodayDateString() };
        setSubscription(newSub);
        localStorage.setItem('ria-subscription-status', JSON.stringify(newSub));
    }

    const aiResponseText = await getRiaResponse(text, messages);

    const aiMessage: Message = {
      id: `ai-${Date.now()}`,
      text: aiResponseText,
      sender: Sender.AI,
    };

    setMessages((prevMessages) => [...prevMessages, aiMessage]);
    setIsLoading(false);
  };

  const handleSubscribe = () => {
    if (window.Telegram && window.Telegram.WebApp) {
      const tg = window.Telegram.WebApp;
      // NOTE: This invoice link must be generated by your backend. This is a placeholder.
      const invoiceLink = 'https://t.me/invoice/example';

      tg.openInvoice(invoiceLink, (status: 'paid' | 'cancelled' | 'failed' | 'pending') => {
        if (status === 'paid') {
          tg.HapticFeedback.notificationOccurred('success');
          const newSub = { ...subscription, tier: SubscriptionTier.PREMIUM };
          setSubscription(newSub);
          localStorage.setItem('ria-subscription-status', JSON.stringify(newSub));
          setShowSubscriptionModal(false);
        } else if (status === 'cancelled' || status === 'failed') {
          tg.HapticFeedback.notificationOccurred(status === 'cancelled' ? 'warning' : 'error');
        }
      });
    } else {
      alert("Subscription is only available through the Telegram app.");
    }
  };

  return (
    <div ref={mainAppRef} className="h-screen w-screen bg-rose-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200 flex flex-col font-sans overflow-hidden">
      <Header />
      <main className="flex-1 flex flex-col overflow-hidden">
        <ChatWindow messages={messages} isLoading={isLoading} />
      </main>
      <MessageInput onSendMessage={handleSendMessage} isLoading={isLoading} />
      <SubscriptionModal 
        isOpen={showSubscriptionModal} 
        onClose={() => setShowSubscriptionModal(false)}
        onSubscribe={handleSubscribe}
      />
    </div>
  );
};

export default App;